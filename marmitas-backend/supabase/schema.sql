-- Reset (opcional - use apenas se quiser limpar tudo)
DROP TABLE IF EXISTS order_items CASCADE;
DROP TABLE IF EXISTS orders CASCADE;
DROP TABLE IF EXISTS product_changeable_foods CASCADE;
DROP TABLE IF EXISTS temp_product_changeable_foods CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS changeable_foods CASCADE;
DROP TABLE IF EXISTS foods CASCADE;
DROP TABLE IF EXISTS delivery_areas CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;
DROP TABLE IF EXISTS user_addresses CASCADE;
DROP TABLE IF EXISTS user_verifications CASCADE;
DROP TABLE IF EXISTS admin_users CASCADE;

-- Configuração inicial
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "pgjwt";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";
CREATE EXTENSION IF NOT EXISTS "pg_graphql";
CREATE EXTENSION IF NOT EXISTS "supabase_vault";

-- Função auxiliar para updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 1. Primeiro criar a tabela de profiles
CREATE TABLE profiles (
    id UUID REFERENCES auth.users(id) PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    full_name TEXT NOT NULL,
    avatar_url TEXT,
    phone TEXT,
    default_address JSONB,
    is_admin BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_active BOOLEAN DEFAULT true,
    phone_verified BOOLEAN DEFAULT false,
    email_verified BOOLEAN DEFAULT false,
    total_spent NUMERIC DEFAULT 0,
    last_purchase TIMESTAMP WITHOUT TIME ZONE
);

-- Tabela admin_users (complementar à profiles para administradores)
CREATE TABLE admin_users (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2. Criar outras tabelas base
CREATE TABLE categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    slug TEXT UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE
);

CREATE TABLE products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_featured BOOLEAN NOT NULL DEFAULT false,
    category_id BIGINT REFERENCES categories(id),
    images TEXT[] DEFAULT ARRAY[]::TEXT[],
    nutritional_info JSONB,
    deleted_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    allows_food_changes BOOLEAN DEFAULT false
);

CREATE TABLE foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE
);

CREATE TABLE changeable_foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE
);

-- 3. Criar tabelas com relações
CREATE TABLE product_changeable_foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_id BIGINT REFERENCES products(id) ON DELETE CASCADE,
    default_food_id BIGINT REFERENCES changeable_foods(id),
    alternative_food_id BIGINT REFERENCES changeable_foods(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_default BOOLEAN DEFAULT false
);

CREATE TABLE temp_product_changeable_foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    temp_product_id BIGINT NOT NULL,
    default_food_id BIGINT REFERENCES changeable_foods(id),
    alternative_food_id BIGINT REFERENCES changeable_foods(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

CREATE TABLE orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES profiles(id),
    status TEXT NOT NULL DEFAULT 'pending',
    total DECIMAL(10,2) NOT NULL,
    notes TEXT,
    delivery_address JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE order_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES orders(id) ON DELETE CASCADE,
    product_id BIGINT REFERENCES products(id),
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE delivery_areas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    zip_codes TEXT[],
    delivery_fee DECIMAL(10,2),
    minimum_order DECIMAL(10,2),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabela de endereços
CREATE TABLE user_addresses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    street VARCHAR(255) NOT NULL,
    number VARCHAR(20) NOT NULL,
    complement VARCHAR(255),
    neighborhood VARCHAR(255) NOT NULL,
    city VARCHAR(255) NOT NULL,
    state VARCHAR(2) NOT NULL,
    postal_code VARCHAR(9) NOT NULL,
    is_default BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabela de verificações (para SMS e email)
CREATE TABLE user_verifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    type VARCHAR(10) NOT NULL, -- 'sms' ou 'email'
    code VARCHAR(6) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. Configurar Storage
INSERT INTO storage.buckets (id, name, public) 
VALUES ('products', 'products', true)
ON CONFLICT (id) DO NOTHING;

INSERT INTO storage.buckets (id, name, public) 
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- 5. Criar triggers
CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_products_updated_at
    BEFORE UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_categories_updated_at
    BEFORE UPDATE ON categories
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_foods_updated_at
    BEFORE UPDATE ON foods
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_changeable_foods_updated_at
    BEFORE UPDATE ON changeable_foods
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_orders_updated_at
    BEFORE UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_delivery_areas_updated_at
    BEFORE UPDATE ON delivery_areas
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_addresses_updated_at
    BEFORE UPDATE ON user_addresses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 6. Criar índices
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_is_active ON products(is_active);
CREATE INDEX idx_products_is_featured ON products(is_featured);
CREATE INDEX idx_products_deleted_at ON products(deleted_at);
CREATE INDEX idx_categories_deleted_at ON categories(deleted_at);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);
CREATE INDEX idx_foods_active ON foods(active);
CREATE INDEX idx_foods_deleted_at ON foods(deleted_at);
CREATE INDEX idx_changeable_foods_deleted_at ON changeable_foods(deleted_at);
CREATE INDEX idx_product_changeable_foods_product ON product_changeable_foods(product_id);
CREATE INDEX idx_delivery_areas_active ON delivery_areas(is_active);
CREATE INDEX idx_user_profiles_phone ON profiles(phone);
CREATE INDEX idx_user_addresses_user_id ON user_addresses(user_id);
CREATE INDEX idx_user_verifications_user_id ON user_verifications(user_id);
CREATE INDEX idx_user_verifications_code ON user_verifications(code);

-- 7. Habilitar RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE changeable_foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_changeable_foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE temp_product_changeable_foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE delivery_areas ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_verifications ENABLE ROW LEVEL SECURITY;

-- 8. Criar políticas
-- Storage policies
DROP POLICY IF EXISTS "Imagens de produtos são públicas" ON storage.objects;
DROP POLICY IF EXISTS "Apenas admins podem gerenciar imagens" ON storage.objects;
DROP POLICY IF EXISTS "Avatar images são públicas" ON storage.objects;
DROP POLICY IF EXISTS "Usuários podem gerenciar seus avatars" ON storage.objects;

CREATE POLICY "Imagens de produtos são públicas"
ON storage.objects FOR SELECT
USING (bucket_id = 'products');

CREATE POLICY "Apenas admins podem gerenciar imagens"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
    bucket_id = 'products' AND
    (EXISTS (
        SELECT 1 FROM profiles
        WHERE profiles.id = auth.uid()
        AND profiles.is_admin = true
    ))
);

CREATE POLICY "Avatar images são públicas"
ON storage.objects FOR SELECT
USING (bucket_id = 'avatars');

CREATE POLICY "Usuários podem gerenciar seus avatars"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
    bucket_id = 'avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text
);

-- Profiles policies
CREATE POLICY "Usuários podem ver seus próprios perfis"
ON profiles FOR SELECT
TO authenticated
USING (auth.uid() = id);

CREATE POLICY "Admins podem ver todos os perfis"
ON profiles FOR SELECT
TO authenticated
USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.is_admin = true
        )
    );

CREATE POLICY "Usuários podem atualizar seus próprios perfis"
ON profiles FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- Products policies
CREATE POLICY "Produtos visíveis para todos"
ON products FOR SELECT
TO authenticated, anon
USING (deleted_at IS NULL);

CREATE POLICY "Apenas admins podem modificar produtos"
ON products FOR ALL
TO authenticated
USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.is_admin = true
        )
    );

-- Categories policies
CREATE POLICY "Categorias visíveis para todos"
ON categories FOR SELECT
TO authenticated, anon
USING (deleted_at IS NULL);

CREATE POLICY "Apenas admins podem modificar categorias"
ON categories FOR ALL
TO authenticated
USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.is_admin = true
        )
    );

-- Orders policies
CREATE POLICY "Usuários podem ver seus próprios pedidos"
ON orders FOR SELECT
TO authenticated
USING (user_id = auth.uid());

CREATE POLICY "Admins podem ver todos os pedidos"
ON orders FOR SELECT
TO authenticated
USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.is_admin = true
        )
    );

CREATE POLICY "Usuários podem criar pedidos"
ON orders FOR INSERT
TO authenticated
WITH CHECK (user_id = auth.uid());

-- Order Items policies
CREATE POLICY "Usuários podem ver seus próprios itens de pedido"
ON order_items FOR SELECT
TO authenticated
USING (
        EXISTS (
            SELECT 1 FROM orders
            WHERE orders.id = order_items.order_id
            AND orders.user_id = auth.uid()
        )
    );

-- Delivery Areas policies
CREATE POLICY "Áreas de entrega visíveis para todos"
ON delivery_areas FOR SELECT
TO authenticated, anon
USING (is_active = true);

CREATE POLICY "Apenas admins podem modificar áreas de entrega"
ON delivery_areas FOR ALL
TO authenticated
USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.is_admin = true
        )
    );

-- Policies para user_addresses
CREATE POLICY "Users can view their own addresses"
    ON user_addresses FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own addresses"
    ON user_addresses FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own addresses"
    ON user_addresses FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own addresses"
    ON user_addresses FOR DELETE
    USING (auth.uid() = user_id);

CREATE POLICY "Admins podem gerenciar endereços de usuários"
    ON user_addresses FOR ALL
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM profiles
            WHERE profiles.id = auth.uid()
            AND profiles.is_admin = true
        )
    );

-- Adicionar após as outras políticas
CREATE POLICY "Permitir autenticação pública"
ON auth.users FOR SELECT
TO anon
USING (true);

-- 9. Criar função e trigger para novos usuários
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, is_admin)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', 'Usuário'),
    COALESCE((NEW.raw_user_meta_data->>'is_admin')::boolean, false)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Criar trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 10. Inserir dados iniciais (admin)
-- Primeiro criar o usuário admin no auth.users
INSERT INTO auth.users (
    id,
    email,
    raw_user_meta_data,
    aud,
    role
) VALUES (
    '00000000-0000-0000-0000-000000000000',
    'admin@marmitasfit.com.br',
    '{"full_name": "Admin"}',
    'authenticated',
    'authenticated'
)
ON CONFLICT (id) DO NOTHING;

-- Depois criar o perfil do admin
INSERT INTO profiles (id, email, full_name, is_admin)
VALUES (
    '00000000-0000-0000-0000-000000000000',
    'admin@marmitasfit.com.br',
    'Admin',
    true
)
ON CONFLICT (id) DO NOTHING;

-- Definir senha para o admin
UPDATE auth.users 
SET encrypted_password = crypt('admin123', gen_salt('bf'))
WHERE email = 'admin@marmitasfit.com.br';

-- Confirmar o email do admin
UPDATE auth.users
SET email_confirmed_at = NOW()
WHERE email = 'admin@marmitasfit.com.br';

-- Função para buscar perfil por ID
CREATE OR REPLACE FUNCTION public.get_profile_by_id(user_id UUID)
RETURNS SETOF profiles
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT *
    FROM profiles
    WHERE id = user_id;
$$;

-- Função para obter endereços de usuário (RPC)
CREATE OR REPLACE FUNCTION public.get_user_addresses(p_user_id UUID)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    result jsonb;
BEGIN
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', ua.id,
            'street', ua.street,
            'number', ua.number,
            'complement', ua.complement,
            'neighborhood', ua.neighborhood,
            'city', ua.city,
            'state', ua.state,
            'postal_code', ua.postal_code,
            'is_default', ua.is_default,
            'created_at', ua.created_at,
            'updated_at', ua.updated_at
        )
    ) INTO result
    FROM user_addresses ua
    WHERE ua.user_id = p_user_id;

    RETURN COALESCE(result, '[]'::jsonb);
END;
$$;

-- Função para limpar endereços padrão
CREATE OR REPLACE FUNCTION public.clear_default_addresses(p_user_id UUID, p_exclude_address_id UUID DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    UPDATE user_addresses
    SET is_default = false
    WHERE user_id = p_user_id
      AND (p_exclude_address_id IS NULL OR id != p_exclude_address_id);
END;
$$;

-- Ajustar permissões para as funções
GRANT EXECUTE ON FUNCTION public.get_profile_by_id(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_profile_by_id(UUID) TO anon;
GRANT EXECUTE ON FUNCTION public.get_user_addresses(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.clear_default_addresses(UUID, UUID) TO authenticated;

-- Ajustar configurações de autenticação
ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

-- Configuração final do usuário admin
UPDATE auth.users
SET 
    raw_user_meta_data = jsonb_build_object(
        'full_name', 'Admin',
        'is_admin', true
    ),
    email_confirmed_at = NOW(),
    last_sign_in_at = NOW(),
    is_sso_user = FALSE,
    banned_until = NULL,
    aud = 'authenticated',
    role = 'authenticated',
    encrypted_password = crypt('admin123', gen_salt('bf'))
WHERE id = '00000000-0000-0000-0000-000000000000';

-- Garantir permissões nos schemas
GRANT USAGE ON SCHEMA auth TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA auth TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO anon, authenticated;
GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO anon, authenticated;

GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL ROUTINES IN SCHEMA public TO anon, authenticated;

-- Função para definir admin
CREATE OR REPLACE FUNCTION make_user_admin(user_email TEXT)
RETURNS void AS $$
BEGIN
  -- Atualizar perfil
  UPDATE profiles 
  SET is_admin = true 
  WHERE email = user_email;
  
  -- Atualizar metadados do usuário
  UPDATE auth.users 
  SET raw_user_meta_data = 
    COALESCE(raw_user_meta_data, '{}'::jsonb) || 
    jsonb_build_object('is_admin', true)
  WHERE email = user_email;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Garantir que o schema public está acessível
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON profiles TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;