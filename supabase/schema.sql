-- ======================================
-- SCHEMA COMPLETO - CATÁLOGO MARMITAS
-- Gerado automaticamente do banco atual
-- ======================================

-- 1. EXTENSÕES
-- Extensões necessárias (as já instaladas são listadas abaixo)

-- Extensão uuid-ossp para geração de UUIDs
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;

-- Extensão pgjwt para JWT
CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA extensions;

-- Extensão pgcrypto para criptografia
CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA extensions;

-- Extensão pg_stat_statements para estatísticas
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA extensions;

-- Extensão supabase_vault para segurança
CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA vault;

-- Extensão pgsodium para criptografia adicional
CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA pgsodium;

-- Extensão pg_graphql para GraphQL
CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA graphql;

-- ======================================
-- 2. FUNÇÕES DE TRIGGER
-- ======================================

-- Função para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para rastrear mudanças de status em pedidos
CREATE OR REPLACE FUNCTION public.track_status_change()
RETURNS TRIGGER AS $$
BEGIN
    -- Se o status mudou, atualiza status_changed_at
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        NEW.status_changed_at = NOW();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para atualizar updated_at em checkout_sessions
CREATE OR REPLACE FUNCTION public.update_checkout_sessions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para atualizar updated_at em integrations_settings
CREATE OR REPLACE FUNCTION public.update_integrations_settings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ======================================
-- 3. TABELAS PRINCIPAIS
-- ======================================

-- Tabela de perfis de usuários
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT NOT NULL UNIQUE,
    full_name TEXT NOT NULL,
    avatar_url TEXT,
    phone TEXT,
    default_address JSONB,
    is_admin BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    is_active BOOLEAN DEFAULT TRUE,
    phone_verified BOOLEAN DEFAULT FALSE,
    email_verified BOOLEAN DEFAULT FALSE,
    total_spent NUMERIC DEFAULT 0,
    last_purchase TIMESTAMP
);

-- Tabela admin_users (para compatibilidade)
CREATE TABLE public.admin_users (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de categorias
CREATE TABLE public.categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    slug TEXT UNIQUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Tabela de produtos
CREATE TABLE public.products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    price NUMERIC NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    is_featured BOOLEAN NOT NULL DEFAULT FALSE,
    category_id BIGINT REFERENCES public.categories(id),
    images TEXT[] DEFAULT ARRAY[]::TEXT[],
    nutritional_info JSONB,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    allows_food_changes BOOLEAN DEFAULT FALSE
);

-- Tabela de alimentos trocáveis
CREATE TABLE public.changeable_foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Tabela de produtos com alimentos trocáveis
CREATE TABLE public.product_changeable_foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE,
    default_food_id BIGINT REFERENCES public.changeable_foods(id) ON DELETE CASCADE,
    alternative_food_id BIGINT REFERENCES public.changeable_foods(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    is_default BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE
);

-- Tabela de foods (para compatibilidade)
CREATE TABLE public.foods (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Tabela de endereços de usuários
CREATE TABLE public.user_addresses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    street VARCHAR NOT NULL,
    number VARCHAR NOT NULL,
    complement VARCHAR,
    neighborhood VARCHAR NOT NULL,
    city VARCHAR NOT NULL,
    state VARCHAR NOT NULL,
    postal_code VARCHAR NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    receiver TEXT NOT NULL DEFAULT '',
    deleted_at TIMESTAMPTZ
);

-- Tabela de verificações de usuário
CREATE TABLE public.user_verifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    type VARCHAR NOT NULL,
    code VARCHAR NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de pedidos
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    status TEXT NOT NULL DEFAULT 'pending',
    total NUMERIC NOT NULL,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    address_id UUID REFERENCES public.user_addresses(id),
    payment_method TEXT,
    payment_details JSONB,
    subtotal NUMERIC,
    delivery_fee NUMERIC,
    deleted_at TIMESTAMPTZ,
    status_changed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de itens de pedidos
CREATE TABLE public.order_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
    product_id BIGINT REFERENCES public.products(id),
    quantity INTEGER NOT NULL,
    price NUMERIC NOT NULL,
    notes TEXT, -- Campo usado para preservar informações de produtos excluídos quando product_id é NULL
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de áreas de entrega
CREATE TABLE public.delivery_areas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type = ANY (ARRAY['fixed'::text, 'variable'::text])),
    state TEXT NOT NULL,
    city TEXT NOT NULL,
    neighborhood TEXT NOT NULL,
    price NUMERIC NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- ======================================
-- 4. TABELAS FINANCEIRAS
-- ======================================

-- Tabela de fornecedores
CREATE TABLE public.suppliers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    contact_person TEXT,
    phone TEXT,
    email TEXT,
    address TEXT,
    notes TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Tabela de gastos/despesas
CREATE TABLE public.expenses (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    description TEXT NOT NULL,
    amount NUMERIC NOT NULL,
    category TEXT NOT NULL,
    date DATE NOT NULL,
    is_recurring BOOLEAN DEFAULT FALSE,
    recurrence_type TEXT CHECK (recurrence_type = ANY (ARRAY['weekly'::text, 'monthly'::text])),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Tabela de pedidos de suprimentos
CREATE TABLE public.supply_orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    supplier_id BIGINT REFERENCES public.suppliers(id),
    description TEXT NOT NULL,
    amount NUMERIC NOT NULL,
    quantity TEXT,
    delivery_date DATE NOT NULL,
    status TEXT DEFAULT 'pending' CHECK (status = ANY (ARRAY['pending'::text, 'delivered'::text, 'overdue'::text, 'cancelled'::text, 'today'::text])),
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- ======================================
-- 5. CONFIGURAÇÕES E SISTEMAS
-- ======================================

-- Tabela de configurações do app
CREATE TABLE public.app_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    value JSONB NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de configurações de integrações
CREATE TABLE public.integrations_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    google_analytics_id TEXT,
    hotjar_id TEXT,
    facebook_pixel_id TEXT,
    google_tag_manager_id TEXT,
    is_google_analytics_enabled BOOLEAN DEFAULT FALSE,
    is_hotjar_enabled BOOLEAN DEFAULT FALSE,
    is_facebook_pixel_enabled BOOLEAN DEFAULT FALSE,
    is_google_tag_manager_enabled BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    whatsapp_number TEXT
);

-- ======================================
-- 6. ANALYTICS E TRACKING
-- ======================================

-- Tabela de sessões de checkout
CREATE TABLE public.checkout_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    session_id TEXT NOT NULL,
    cart_items JSONB NOT NULL,
    started_at TIMESTAMPTZ DEFAULT NOW(),
    checkout_entered_at TIMESTAMPTZ,
    address_selected_at TIMESTAMPTZ,
    payment_method_selected_at TIMESTAMPTZ,
    abandoned_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    order_id INTEGER REFERENCES public.orders(id),
    total_value NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    recovered_at TIMESTAMPTZ, -- Timestamp de quando um checkout abandonado foi recuperado (cliente fez nova compra)
    recovery_order_id INTEGER REFERENCES public.orders(id) -- ID do pedido que recuperou o checkout abandonado
);

-- Tabela de visualizações de páginas
CREATE TABLE public.page_views (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    page_path TEXT NOT NULL,
    page_title TEXT NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    session_id TEXT NOT NULL,
    referrer TEXT,
    user_agent TEXT,
    viewport_width INTEGER,
    viewport_height INTEGER,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de eventos customizados
CREATE TABLE public.custom_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_name TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb,
    page_path TEXT NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    session_id TEXT NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de sessões analíticas
CREATE TABLE public.analytics_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id TEXT NOT NULL UNIQUE,
    user_id UUID REFERENCES auth.users(id),
    device_type TEXT,
    browser TEXT,
    os TEXT,
    country TEXT,
    region TEXT,
    city TEXT,
    ip_address INET,
    started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ended_at TIMESTAMPTZ,
    duration_seconds INTEGER,
    pages_visited INTEGER DEFAULT 0,
    events_count INTEGER DEFAULT 0,
    is_bounce BOOLEAN DEFAULT FALSE,
    referrer_domain TEXT,
    utm_source TEXT,
    utm_medium TEXT,
    utm_campaign TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabela de analytics de produtos
CREATE TABLE public.product_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id INTEGER NOT NULL REFERENCES public.products(id),
    date DATE NOT NULL,
    views INTEGER DEFAULT 0,
    unique_views INTEGER DEFAULT 0,
    cart_additions INTEGER DEFAULT 0,
    purchases INTEGER DEFAULT 0,
    revenue NUMERIC DEFAULT 0,
    conversion_rate NUMERIC DEFAULT 0,
    avg_time_on_page INTEGER DEFAULT 0,
    bounce_rate NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(product_id, date)
);

-- Tabela de funil de conversão
CREATE TABLE public.conversion_funnel (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id TEXT NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    step_name TEXT NOT NULL,
    product_id INTEGER REFERENCES public.products(id),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    additional_data JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ======================================
-- 7. TRIGGERS
-- ======================================

-- Trigger para atualizar updated_at nas tabelas principais
CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_products_updated_at
    BEFORE UPDATE ON public.products
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_categories_updated_at
    BEFORE UPDATE ON public.categories
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_foods_updated_at
    BEFORE UPDATE ON public.foods
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_changeable_foods_updated_at
    BEFORE UPDATE ON public.changeable_foods
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_orders_updated_at
    BEFORE UPDATE ON public.orders
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_delivery_areas_updated_at
    BEFORE UPDATE ON public.delivery_areas
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_addresses_updated_at
    BEFORE UPDATE ON public.user_addresses
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_suppliers_updated_at
    BEFORE UPDATE ON public.suppliers
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_expenses_updated_at
    BEFORE UPDATE ON public.expenses
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_supply_orders_updated_at
    BEFORE UPDATE ON public.supply_orders
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_product_analytics_updated_at
    BEFORE UPDATE ON public.product_analytics
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

-- Triggers específicos
CREATE TRIGGER track_orders_status_change
    BEFORE UPDATE ON public.orders
    FOR EACH ROW
    EXECUTE FUNCTION public.track_status_change();

CREATE TRIGGER checkout_sessions_updated_at
    BEFORE UPDATE ON public.checkout_sessions
    FOR EACH ROW
    EXECUTE FUNCTION public.update_checkout_sessions_updated_at();

CREATE TRIGGER update_integrations_settings_updated_at
    BEFORE UPDATE ON public.integrations_settings
    FOR EACH ROW
    EXECUTE FUNCTION public.update_integrations_settings_updated_at();

-- ======================================
-- 8. ÍNDICES
-- ======================================

-- Índices para produtos
CREATE INDEX idx_products_category ON public.products(category_id);
CREATE INDEX idx_products_is_active ON public.products(is_active);
CREATE INDEX idx_products_is_featured ON public.products(is_featured);
CREATE INDEX idx_products_deleted_at ON public.products(deleted_at);

-- Índices para categorias
CREATE INDEX idx_categories_deleted_at ON public.categories(deleted_at);

-- Índices para pedidos
CREATE INDEX idx_orders_user_id ON public.orders(user_id);
CREATE INDEX idx_orders_status ON public.orders(status);

-- Índices para itens de pedidos
CREATE INDEX idx_order_items_order ON public.order_items(order_id);
CREATE INDEX idx_order_items_product ON public.order_items(product_id);

-- Índices para foods
CREATE INDEX idx_foods_active ON public.foods(active);
CREATE INDEX idx_foods_deleted_at ON public.foods(deleted_at);

-- Índices para changeable_foods
CREATE INDEX idx_changeable_foods_deleted_at ON public.changeable_foods(deleted_at);

-- Índices para product_changeable_foods
CREATE INDEX idx_product_changeable_foods_product ON public.product_changeable_foods(product_id);

-- Índices para delivery_areas
CREATE INDEX idx_delivery_areas_active ON public.delivery_areas(is_active);

-- Índices para profiles
CREATE INDEX idx_user_profiles_phone ON public.profiles(phone);

-- Índices para user_addresses
CREATE INDEX idx_user_addresses_user_id ON public.user_addresses(user_id);

-- Índices para user_verifications
CREATE INDEX idx_user_verifications_user_id ON public.user_verifications(user_id);
CREATE INDEX idx_user_verifications_code ON public.user_verifications(code);

-- ======================================
-- 9. FOREIGN KEY CONSTRAINTS ADICIONAIS
-- ======================================

-- ======================================
-- 10. STORAGE BUCKETS
-- ======================================

-- Bucket para imagens gerais
INSERT INTO storage.buckets (id, name, public, file_size_limit)
VALUES ('images', 'images', TRUE, 5242880) -- 5MB limit
ON CONFLICT (id) DO NOTHING;

-- Bucket para produtos
INSERT INTO storage.buckets (id, name, public)
VALUES ('products', 'products', TRUE)
ON CONFLICT (id) DO NOTHING;

-- ======================================
-- 11. RLS POLICIES
-- ======================================

-- Habilitar RLS nas tabelas
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.changeable_foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.product_changeable_foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.foods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.delivery_areas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.supply_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.integrations_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.checkout_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.page_views ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.custom_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.analytics_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.product_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversion_funnel ENABLE ROW LEVEL SECURITY;

-- Policies para auth.users
ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Permitir acesso público para autenticação" ON auth.users
FOR SELECT USING (true) TO anon, authenticated;

-- Policies para profiles
CREATE POLICY "Acesso público a profiles" ON public.profiles
FOR ALL USING (auth.uid() IS NOT NULL);

CREATE POLICY "Permitir inserção de perfis pelo trigger" ON public.profiles
FOR INSERT WITH CHECK (true) TO anon, authenticated;

CREATE POLICY "Usuários podem atualizar seus próprios dados" ON public.profiles
FOR UPDATE USING (id = auth.uid()) WITH CHECK (id = auth.uid()) TO authenticated;

-- Policies para categories
CREATE POLICY "Permitir leitura de categorias" ON public.categories
FOR SELECT USING (true) TO anon, authenticated;

CREATE POLICY "Acesso a categories para admins" ON public.categories
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para products
CREATE POLICY "Produtos visíveis para todos sem autenticação" ON public.products
FOR SELECT USING (deleted_at IS NULL);

CREATE POLICY "Acesso a products para admins" ON public.products
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para changeable_foods
CREATE POLICY "Permitir tudo para usuários autenticados" ON public.changeable_foods
FOR ALL USING (true) WITH CHECK (true) TO authenticated;

-- Policies para product_changeable_foods
CREATE POLICY "Enable all operations for authenticated users" ON public.product_changeable_foods
FOR ALL USING (true) WITH CHECK (true) TO authenticated;

-- Policies para user_addresses
CREATE POLICY "Users can view their own addresses" ON public.user_addresses
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own addresses" ON public.user_addresses
FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own addresses" ON public.user_addresses
FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own addresses" ON public.user_addresses
FOR DELETE USING (auth.uid() = user_id);

CREATE POLICY "Enable read access for authenticated users" ON public.user_addresses
FOR SELECT USING ((auth.uid() = user_id) AND (deleted_at IS NULL));

-- Policies para orders
CREATE POLICY "Enable read access for authenticated users" ON public.orders
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Enable insert access for authenticated users" ON public.orders
FOR INSERT WITH CHECK (auth.uid() = user_id) TO authenticated;

CREATE POLICY "Enable update access for authenticated users" ON public.orders
FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id) TO authenticated;

CREATE POLICY "Usuários podem ver seus próprios pedidos" ON public.orders
FOR SELECT USING ((user_id = auth.uid()) AND (deleted_at IS NULL)) TO authenticated;

CREATE POLICY "Admins podem ver todos os pedidos" ON public.orders
FOR SELECT USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
)) TO authenticated;

CREATE POLICY "Admins podem excluir pedidos" ON public.orders
FOR DELETE USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
)) TO authenticated;

-- Policies para order_items
CREATE POLICY "Enable read access for authenticated users" ON public.order_items
FOR SELECT USING (EXISTS (
    SELECT 1 FROM public.orders 
    WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid()
)) TO authenticated;

CREATE POLICY "Enable insert access for authenticated users" ON public.order_items
FOR INSERT WITH CHECK (EXISTS (
    SELECT 1 FROM public.orders 
    WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid()
)) TO authenticated;

CREATE POLICY "Enable update access for authenticated users" ON public.order_items
FOR UPDATE 
USING (EXISTS (
    SELECT 1 FROM public.orders 
    WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid()
))
WITH CHECK (EXISTS (
    SELECT 1 FROM public.orders 
    WHERE orders.id = order_items.order_id AND orders.user_id = auth.uid()
)) TO authenticated;

CREATE POLICY "Admins podem excluir itens de pedidos" ON public.order_items
FOR DELETE USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
)) TO authenticated;

-- Policies para delivery_areas
CREATE POLICY "Enable read access for all users" ON public.delivery_areas
FOR SELECT USING (true);

CREATE POLICY "Enable insert for authenticated users only" ON public.delivery_areas
FOR INSERT WITH CHECK (auth.role() = 'authenticated'::text);

CREATE POLICY "Enable update for authenticated users only" ON public.delivery_areas
FOR UPDATE USING (auth.role() = 'authenticated'::text);

CREATE POLICY "Enable delete for authenticated users only" ON public.delivery_areas
FOR DELETE USING (auth.role() = 'authenticated'::text);

-- Policies para suppliers
CREATE POLICY "Admin can manage suppliers" ON public.suppliers
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para expenses
CREATE POLICY "Admin can manage expenses" ON public.expenses
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para supply_orders
CREATE POLICY "Admin can manage supply_orders" ON public.supply_orders
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para app_settings
CREATE POLICY "Everyone can read settings" ON public.app_settings
FOR SELECT USING (true);

CREATE POLICY "Only admins can manage settings" ON public.app_settings
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para integrations_settings
CREATE POLICY "Usuários podem ver configurações de integrações" ON public.integrations_settings
FOR SELECT USING (true);

CREATE POLICY "Admins podem atualizar configurações de integrações" ON public.integrations_settings
FOR UPDATE USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para checkout_sessions
CREATE POLICY "Users can manage their own checkout sessions" ON public.checkout_sessions
FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all checkout sessions" ON public.checkout_sessions
FOR SELECT USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- Policies para analytics
CREATE POLICY "Users can insert their own page views" ON public.page_views
FOR INSERT WITH CHECK ((auth.uid() = user_id) OR (user_id IS NULL));

CREATE POLICY "Admins can access all analytics data" ON public.page_views
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

CREATE POLICY "Users can insert their own custom events" ON public.custom_events
FOR INSERT WITH CHECK ((auth.uid() = user_id) OR (user_id IS NULL));

CREATE POLICY "Admins can access all custom events" ON public.custom_events
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

CREATE POLICY "Users can insert their own analytics sessions" ON public.analytics_sessions
FOR INSERT WITH CHECK ((auth.uid() = user_id) OR (user_id IS NULL));

CREATE POLICY "Admins can access all analytics sessions" ON public.analytics_sessions
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

CREATE POLICY "Admins can access all product analytics" ON public.product_analytics
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

CREATE POLICY "Users can insert their own conversion funnel data" ON public.conversion_funnel
FOR INSERT WITH CHECK ((auth.uid() = user_id) OR (user_id IS NULL));

CREATE POLICY "Admins can access all conversion funnel" ON public.conversion_funnel
FOR ALL USING (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
));

-- ======================================
-- 12. STORAGE POLICIES
-- ======================================

-- Policies para storage.objects
CREATE POLICY "Imagens visíveis publicamente" ON storage.objects
FOR SELECT USING (bucket_id = 'images') TO public;

CREATE POLICY "Upload permitido para usuários autenticados" ON storage.objects
FOR INSERT WITH CHECK ((bucket_id = 'images') AND (auth.role() = 'authenticated'::text)) TO public;

CREATE POLICY "Imagens de produtos são públicas" ON storage.objects
FOR SELECT USING (bucket_id = 'products') TO public;

CREATE POLICY "Apenas admins podem gerenciar imagens" ON storage.objects
FOR INSERT WITH CHECK ((bucket_id = 'products') AND (EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.is_admin = true
))) TO authenticated;

-- ======================================
-- 13. FUNÇÕES AUXILIARES
-- ======================================

-- Função para criar usuário quando registra
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, phone, is_admin)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', 'Usuário'),
    NEW.raw_user_meta_data->>'phone',
    COALESCE((NEW.raw_user_meta_data->>'is_admin')::boolean, false)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger para criação automática de perfil
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Função para obter endereços de usuário
CREATE OR REPLACE FUNCTION public.get_user_addresses(p_user_id UUID)
RETURNS JSONB[] AS $$
DECLARE
  result JSONB[];
BEGIN
  SELECT array_agg(to_jsonb(t)) INTO result
  FROM (
    SELECT * FROM public.user_addresses 
    WHERE user_id = p_user_id
    ORDER BY is_default DESC
  ) t;
  
  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    RAISE LOG 'Erro na função get_user_addresses: %', SQLERRM;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para limpar endereços padrão
CREATE OR REPLACE FUNCTION public.clear_default_addresses(p_user_id UUID, p_exclude_address_id UUID)
RETURNS VOID AS $$
BEGIN
  -- Atualiza todos os endereços do usuário para não serem padrão
  -- exceto o endereço que está sendo atualmente editado (se for fornecido)
  UPDATE public.user_addresses
  SET is_default = false
  WHERE 
    user_id = p_user_id
    AND (p_exclude_address_id IS NULL OR id != p_exclude_address_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para tornar usuário admin
CREATE OR REPLACE FUNCTION public.make_user_admin(user_email TEXT)
RETURNS VOID AS $$
BEGIN
  -- Atualizar perfil
  UPDATE public.profiles 
  SET is_admin = true 
  WHERE email = user_email;
  
  -- Atualizar metadados do usuário
  UPDATE auth.users 
  SET raw_user_meta_data = 
    COALESCE(raw_user_meta_data, '{}'::jsonb) || 
    jsonb_build_object('is_admin', true)
  WHERE email = user_email;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para deletar categoria e mover produtos para categoria padrão
CREATE OR REPLACE FUNCTION public.delete_category(target_category_id INTEGER)
RETURNS VOID AS $$
DECLARE
    default_category_id INTEGER;
BEGIN
    -- Verificar se estamos tentando excluir a categoria padrão (id=1)
    IF target_category_id = 1 THEN
        RAISE EXCEPTION 'A categoria padrão não pode ser excluída';
    END IF;

    -- Verificar/criar a categoria padrão "Sem Categoria"
    SELECT id INTO default_category_id FROM public.categories WHERE name = 'Sem Categoria' LIMIT 1;
    
    -- Se não existir, criar a categoria padrão
    IF default_category_id IS NULL THEN
        INSERT INTO public.categories (name, slug) 
        VALUES ('Sem Categoria', 'sem-categoria') 
        RETURNING id INTO default_category_id;
        
        -- Garantir que o ID seja 1
        UPDATE public.categories SET id = 1 WHERE id = default_category_id;
        default_category_id := 1;
        
        -- Atualizar a sequência
        PERFORM setval('categories_id_seq', 
                      (SELECT COALESCE(MAX(id), 1) FROM public.categories), 
                      true);
    END IF;
    
    -- Mover todos os produtos para a categoria padrão
    UPDATE public.products 
    SET category_id = default_category_id
    WHERE category_id = target_category_id;
    
    -- Deletar a categoria
    DELETE FROM public.categories 
    WHERE id = target_category_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- Função para deletar alimento trocável
CREATE OR REPLACE FUNCTION public.delete_changeable_food(food_id BIGINT)
RETURNS VOID AS $$
BEGIN
    -- Primeiro, delete todos os registros relacionados em product_changeable_foods
    DELETE FROM public.product_changeable_foods 
    WHERE default_food_id = food_id OR alternative_food_id = food_id;
    
    -- Depois, delete o registro em changeable_foods
    DELETE FROM public.changeable_foods WHERE id = food_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para buscar pedidos de usuário com detalhes
CREATE OR REPLACE FUNCTION public.get_user_orders_with_details(p_user_id UUID)
RETURNS TABLE(
  id BIGINT,
  user_id UUID,
  status TEXT,
  total NUMERIC,
  subtotal NUMERIC,
  delivery_fee NUMERIC,
  payment_method TEXT,
  payment_status TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  status_changed_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  delivery_address JSONB,
  items JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.id,
    o.user_id,
    o.status,
    o.total,
    o.subtotal,
    o.delivery_fee,
    o.payment_method,
    'paid'::TEXT as payment_status,
    o.created_at,
    o.updated_at,
    COALESCE(o.status_changed_at, o.created_at) as status_changed_at,
    CASE 
      WHEN o.status = 'completed' THEN COALESCE(o.status_changed_at, o.updated_at)
      ELSE NULL 
    END as completed_at,
    -- Endereço como JSONB
    CASE 
      WHEN ua.id IS NOT NULL THEN
        jsonb_build_object(
          'id', ua.id,
          'receiver', ua.receiver,
          'street', ua.street,
          'number', ua.number,
          'complement', ua.complement,
          'neighborhood', ua.neighborhood,
          'city', ua.city,
          'state', ua.state,
          'postal_code', ua.postal_code
        )
      ELSE NULL
    END as delivery_address,
    -- Itens como JSONB array (INCLUINDO NOTES!)
    COALESCE(
      (
        SELECT jsonb_agg(
          jsonb_build_object(
            'id', oi.id,
            'order_id', oi.order_id,
            'product_id', oi.product_id,
            'quantity', oi.quantity,
            'price', oi.price,
            'unit_price', oi.price,
            'total_price', oi.price * oi.quantity,
            'notes', oi.notes,
            'product', jsonb_build_object(
              'title', COALESCE(p.title, 'Produto Removido'),
              'image_url', CASE 
                WHEN p.images IS NOT NULL AND array_length(p.images, 1) > 0 
                THEN p.images[1] 
                ELSE NULL 
              END
            )
          )
        )
        FROM public.order_items oi
        LEFT JOIN public.products p ON oi.product_id = p.id
        WHERE oi.order_id = o.id
      ),
      '[]'::jsonb
    ) as items
  FROM public.orders o
  LEFT JOIN public.user_addresses ua ON o.address_id = ua.id
  WHERE o.user_id = p_user_id
    AND o.deleted_at IS NULL
  ORDER BY o.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Função para aggregate analytics de produtos
CREATE OR REPLACE FUNCTION public.aggregate_product_analytics()
RETURNS VOID AS $$
DECLARE
    target_date DATE := CURRENT_DATE - INTERVAL '1 day';
BEGIN
    -- Inserir ou atualizar métricas de produto para o dia anterior
    INSERT INTO public.product_analytics (product_id, date, views, unique_views, cart_additions, purchases, revenue)
    SELECT 
        p.id as product_id,
        target_date as date,
        COALESCE(pv.views, 0) as views,
        COALESCE(pv.unique_views, 0) as unique_views,
        COALESCE(ce.cart_additions, 0) as cart_additions,
        COALESCE(o.purchases, 0) as purchases,
        COALESCE(o.revenue, 0) as revenue
    FROM public.products p
    LEFT JOIN (
        -- Contagem de visualizações de produto
        SELECT 
            CAST(SPLIT_PART(page_path, '/', 3) AS INTEGER) as product_id,
            COUNT(*) as views,
            COUNT(DISTINCT session_id) as unique_views
        FROM public.page_views 
        WHERE page_path LIKE '/produto/%'
        AND DATE(timestamp) = target_date
        GROUP BY SPLIT_PART(page_path, '/', 3)
    ) pv ON p.id = pv.product_id
    LEFT JOIN (
        -- Contagem de adições ao carrinho
        SELECT 
            CAST(event_data->>'product_id' AS INTEGER) as product_id,
            COUNT(*) as cart_additions
        FROM public.custom_events 
        WHERE event_name = 'add_to_cart'
        AND DATE(timestamp) = target_date
        GROUP BY event_data->>'product_id'
    ) ce ON p.id = ce.product_id
    LEFT JOIN (
        -- Contagem de compras e receita
        SELECT 
            oi.product_id,
            COUNT(DISTINCT o.id) as purchases,
            SUM(oi.quantity * oi.price) as revenue
        FROM public.orders o
        JOIN public.order_items oi ON o.id = oi.order_id
        WHERE DATE(o.created_at) = target_date
        AND o.status = 'completed'
        GROUP BY oi.product_id
    ) o ON p.id = o.product_id
    ON CONFLICT (product_id, date) 
    DO UPDATE SET
        views = EXCLUDED.views,
        unique_views = EXCLUDED.unique_views,
        cart_additions = EXCLUDED.cart_additions,
        purchases = EXCLUDED.purchases,
        revenue = EXCLUDED.revenue,
        conversion_rate = CASE 
            WHEN EXCLUDED.views > 0 
            THEN EXCLUDED.purchases::DECIMAL / EXCLUDED.views 
            ELSE 0 
        END,
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- ======================================
-- 14. DADOS INICIAIS
-- ======================================

-- Inserir categoria padrão
INSERT INTO public.categories (id, name, slug) 
VALUES (1, 'Sem Categoria', 'sem-categoria')
ON CONFLICT (id) DO NOTHING;

-- Ajustar a sequência de categorias
SELECT setval('categories_id_seq', GREATEST(1, (SELECT COALESCE(MAX(id), 0) FROM public.categories)), true);

-- Inserir dados iniciais de configurações
INSERT INTO public.app_settings (key, value, description) VALUES
('delivery_fee', '5.00', 'Taxa padrão de entrega')
ON CONFLICT (key) DO NOTHING;

-- Inserir configuração inicial de integrações
INSERT INTO public.integrations_settings DEFAULT VALUES
ON CONFLICT DO NOTHING;

-- ======================================
-- 15. PERMISSÕES FINAIS
-- ======================================

-- Ajustar permissões para as funções
GRANT EXECUTE ON FUNCTION public.get_user_addresses(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.clear_default_addresses(UUID, UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.delete_category(INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.delete_changeable_food(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_orders_with_details(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.aggregate_product_analytics() TO authenticated;

-- Garantir permissões nos schemas
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL ROUTINES IN SCHEMA public TO anon, authenticated;

-- ======================================
-- FIM DO SCHEMA
-- ======================================

COMMENT ON SCHEMA public IS 'Schema completo do Catálogo Marmitas - Gerado automaticamente do banco atual'; 